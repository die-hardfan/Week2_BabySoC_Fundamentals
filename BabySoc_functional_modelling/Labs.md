# VSD BabySoC Functional Modelling: Theory 

This is an overview of the ports and functional description of VSDBabySoC.

## 1. avsddac.v 

This is a behavioral Verilog model (not synthesizable) that implements a simple analog-style DAC (digital-to-analog converter) in simulation using real (floating-point) arithmetic. It converts the 10-bit input D into a real voltage OUT somewhere between VREFL and VREFH. 
```text
   output      OUT;
   input [9:0] D;
   input       VREFH;
   input       VREFL;
```
The module converts the 10 bit `D` to an appropriate voltage value between `VREFH` and `VREFL`. 

<details>
  <summary>Detailed Explanation</summary>

```bash
module avsddac (
   OUT,
   D,
   VREFH,
   VREFL
);

// Port declarations (old-style Verilog)
// `OUT` declared below as a real reg; `D` is a 10-bit input, VREFH/VREFL are inputs
   output      OUT;
   input [9:0] D;
   input       VREFH;
   input       VREFL;
   
// Internal declarations
// OUT is declared as a real reg — holds floating-point value for simulation.
   reg  real OUT;
// Declares the reference pins as wires of type real (simulation-only).
   wire real VREFL;
   wire real VREFH;

// A real variable to hold a NaN value for checks (0.0/0.0 produces NaN in simulator)
   real NaN;
// Enable signal — here it is a wire driven to constant 1 below.
   wire EN;

// Extend D to 11 bits so division by 1023 works with integer numerator 0..1023
   wire [10:0] Dext;	// unsigned extended

// Zero-extend D to 11 bits: Dext ranges 0..1023
   assign Dext = {1'b0, D};
// Hardwired enable; EN is always 1 here (so DAC always enabled)
   assign EN = 1;

// initial block: executed at time 0 in simulation
   initial begin
      NaN = 0.0 / 0.0;           // create a NaN value (simulator-specific)
      if (EN == 1'b0) begin
         OUT <= 0.0;            // non-blocking assignment to OUT (unusual in initial)
      end
      else if (VREFH == NaN) begin
         OUT <= NaN;           // attempt to detect NaN on VREFH
      end
      else if (VREFL == NaN) begin
         OUT <= NaN;           // attempt to detect NaN on VREFL
      end
      else if (EN == 1'b1) begin
         // compute analog output as linear interpolation from VREFL..VREFH
         OUT <= VREFL + ($itor(Dext) / 1023.0) * (VREFH - VREFL);
      end
      else begin
         OUT <= NaN;
      end
   end

// Combinational-style always block triggered when any of these signals changes
// Note: using non-blocking (<=) here is unusual for combinational logic
   always @(D or EN or VREFH or VREFL) begin
      if (EN == 1'b0) begin
         OUT <= 0.0;
      end
      else if (VREFH == NaN) begin
         OUT <= NaN;
      end
      else if (VREFL == NaN) begin
         OUT <= NaN;
      end
      else if (EN == 1'b1) begin
         // real arithmetic: convert Dext (integer) to real and scale by 1/1023
         OUT <= VREFL + ($itor(Dext) / 1023.0) * (VREFH - VREFL);
      end
      else begin
         OUT <= NaN;
      end
   end
endmodule
```
</details>

---

## 2. avsdpll.v

```text
module avsdpll (
   output reg  CLK,        // Output clock of the PLL
   input  wire VCO_IN,     // Input from VCO (not really used in this sim)
   input  wire ENb_CP,     // Charge pump enable (not used here)
   input  wire ENb_VCO,    // VCO enable (active-low)
   input  wire REF         // Reference given as real value
);
```
CLK: The output clock generated by this PLL (VCO output). Declared as reg because it will be updated in procedural blocks (always).
VCO_IN: Input to the Voltage-Controlled Oscillator. In this code, it’s not used. Possibly for future expansion or analog modeling.
ENb_CP: Enable/disable for the charge pump. Currently unused.
ENb_VCO: Enable for the VCO. Controls whether the output CLK toggles or is held low.
REF: Reference clock input. The PLL locks to this clock

The module starts with CLK = 0 and period = 25 ns (40 MHz).
If ENb_VCO = 1, the CLK toggles every period/2 ns.
Each time the reference clock REF has a rising edge:
Calculate the reference period.
Adjust the VCO period to 1/8 of the reference clock period.
This simulates a frequency-multiplying PLL with VCO locking to a reference.

Important: This is behavioral code for simulation, not synthesizable RTL. The #(delay) and real types are purely for timing simulation.

<details>
  <summary> Detailed Explanation </summary>

Real Variables
real period, lastedge, refpd;


period: The current period of the output CLK in nanoseconds. Used for timing delays.

lastedge: Stores the time of the last rising edge of REF.

refpd: The reference clock period (time between two REF rising edges).

Note: real type is used for simulation with time delays in #(...) constructs. Cannot be synthesized to hardware—this is behavioral/testbench code, not RTL for an FPGA/ASIC.

Initial Block
initial begin
   lastedge = 0.0;
   period = 25.0; // 25ns period = 40MHz
   CLK <= 0;
end


lastedge = 0.0; → Initialize the last REF edge timestamp.

period = 25.0 → Default VCO period is 25ns, i.e., 40 MHz frequency.

CLK <= 0; → Initialize the output clock to 0.

This sets the starting conditions of the PLL simulation.

Clock Toggling (VCO Behavior)
always @(CLK or ENb_VCO) begin
   if (ENb_VCO == 1'b1) begin
      #(period / 2.0);
      CLK <= (CLK === 1'b0);
   end
   else if (ENb_VCO == 1'b0) begin
      CLK <= 1'b0;
   end 
   else begin
      CLK <= 1'bx;
   end
end


This always block toggles the CLK output to simulate the VCO.

ENb_VCO == 1 → VCO enabled, clock toggles at period/2 delay.

#(period / 2.0); → Wait half a period before toggling the clock.

CLK <= (CLK === 1'b0); → If CLK was 0, set to 1; else set to 0 (toggles).

ENb_VCO == 0 → VCO disabled, hold CLK at 0.

else → If ENb_VCO is unknown (x), CLK is set to unknown 1'bx.

Essentially, this simulates a free-running oscillator controlled by ENb_VCO and the current period.

Reference Clock Edge Processing
always @(posedge REF) begin
   if (lastedge > 0.0) begin
      refpd = $realtime - lastedge;
      // Adjust period towards 1/8 the reference period
      //period = (0.99 * period) + (0.01 * (refpd / 8.0));
      period =  (refpd / 8.0) ;
   end
   lastedge = $realtime;
end


This block adjusts the VCO period based on the reference clock, simulating phase-locking behavior.

@(posedge REF) → Triggered on each rising edge of REF.

if (lastedge > 0.0) → Skip the first edge because there’s no previous timestamp yet.

refpd = $realtime - lastedge; → Calculate the period of the reference clock. $realtime gives the simulation time in ns.

period = (refpd / 8.0); → Sets the VCO period to 1/8th of the reference period, i.e., this PLL multiplies the reference frequency by 8.

The commented line //period = (0.99 * period) + (0.01 * (refpd / 8.0)); would have been a smoother approach (exponential averaging) to prevent abrupt frequency jumps.

lastedge = $realtime; → Update timestamp for next edge calculation.

This is the core PLL “locking” mechanism: it adjusts the output clock period to match a multiple of the reference clock.

</details>

---

## 3. rvmyth.tlv

```text
   module rvmyth(
      output reg [9:0] OUT,
      input CLK,
      input reset
   );
```
`OUT`: reflects the contents of register `r17` within the register file. 
`CLK`: input clock signal required for functioning of the core
`reset`: active high reset that pulls relevant values (like PC, rd_en) to 0. 

<details>
  <summary> Detailed Explanation </summary>
  
</details>

---

## 4. vsdbabysoc.v
This is the wrapper function that makes the interconnections between the 3 components.

```text
module vsdbabysoc (
   output wire OUT,
   input  wire reset,
   input  wire VCO_IN,
   input  wire ENb_CP,
   input  wire ENb_VCO,
   input  wire REF,
    input  wire VREFL,
   input  wire VREFH
);
```

`OUT`: Final output of the SoC (from the DAC).
`reset`: Resets the RISC-V core.
`VCO_IN`: Input to the PLL's VCO (currently used in the PLL module).
`ENb_CP`: Enable/disable the charge pump in the PLL.
`ENb_VCO`: Enable/disable the VCO output.
`REF`: Reference clock for the PLL.
`VREFH`: DAC reference voltage (high).
`VREFL`: DAC low reference (commented out, possibly defaulted to 0).

<details>
  <summary> Detailed Explanation </summary>
  
</details>

---

## 5. testbench.v
The testbench module doesn't have any ports and is responsible for stimulus generation and observation.

<details>
  <summary> Detailed Explanation </summary>
  
</details>


# VSD BabySoC Functional Modelling: Labs

## Environment Setup

**Tools required:** 
 - git (for git cloning the source files)
 - sandpiper environment (required for .tlv to .v conversion cuz processor source code is in TL-Verilog)
 - python3 (to install sandpiper)
 - iVerilog (for simulation)
 - GTKwave (for waveform viewing)

All this is being done on an Ubuntu terminal.

```bash
sudo apt update
sudo apt-get install python3 python3-pip //to install python
```
Python is now installed. To install `sandpiper` : 
```bash
pip3 install --user pyyaml click sandpiper-saas //this didn't work on my system, but it maybe used
```
OR 
```bash
sudo apt install pipx //install pipx
pipx install sandpiper-saas
pipx ensurepath 
```
<details>
  <summary> why pip install didn't work </summary>
  
Ubuntu 22.04+ (or Debian-based systems) now use PEP 668 “externally managed environments”.
This means:
The system Python (/usr/bin/python3) is managed by the OS package manager (apt).
You are not allowed to install Python packages system-wide using sudo pip3.
Doing so can break system tools that rely on the OS Python.
Sandpiper is probably not a Debian packaged application, so it may be easiest to use pipx install xyz, which will manage a virtual environment for you. Make sure you have pipx installed.
Some changes to the path may be required after the command. 
> pipx ensurepath
This ensures that pipx’s binary installation directory is added to your system PATH so installed packages can be run from the command line.
</details>

The SandPiper code generator helps you write Verilog or SystemVerilog code more productively from TL-Verilog. Most open-source projects use SandPiper SaaS, which provides a command-line interface to run SandPiper in the cloud.
```bash
sanpiper-saas -i my.tlv -o my.sv //command for conversion
```
git, iVerilog, and GTKwave have been installed as part of earlier tasks.

---

## Simulation 

1. Git clone the project files from [here](https://github.com/manili/VSDBabySoC).
```bash
git clone https://github.com/manili/VSDBabySoC week2_files
```
2. Translation of rvmyth.tlv into .v files.
```bash
sandpiper-saas -i rvmyth.tlv -o rvmyth.v
```
This generates two files, `rvmyth.v` and `rvmyth_gen.v`. Both of them are necessary for proper simulation. 
Include both files when compiling. The testbench instantiates the main module from `rvmyth.v`. `rvmyth_gen.v` provides the necessary supporting definitions.
Also, all lines with `line in rvmyth.v file must be commented out (it leads to unexpected error otherwise).
<details>
  <summary>Why error?</summary>

Lines like:
```
`line 254 "rvmyth.tlv" 2
```
are TL-Verilog “line directives” used for debugging/error reporting.
Icarus Verilog does not understand them unless you explicitly enable SystemVerilog (-g2012) and even then, some TLV-generated directives are not supported.
</details>

3. Simulate the files.
```bash
iverilog -g2012 -o ~/week2_files/output/pre_synth_sim/pre_synth_sim.out -DPRE_SYNTH_SIM -I ~/week2_files/src/include -I ~/week2_files/src/module ~/week2_files/src/module/testbench.v //simulation
cd output/pre_synth_sim //navigate to the output directory
./pre_synth_sim.out //execution of the .out file
gtkwave pre_synth_sim.vcd //waveform viewing
```
-g2012 : Use the Verilog 2012 standard.
-o <output_file_path> : Specify the output file for the compiled simulation executable.
-D<MACRO_NAME> : Define a preprocessor macro for conditional compilation.
-I <include_dir1> -I <include_dir2> : Add directories to the search path for `\`include` files.
<verilog_file> : The main Verilog file (usually a testbench) to compile.

Don't include `vsdbabysoc.v` module in the simulation command, cuz the testbench already includes it.

> ./pre_synth_sim.out
is required to actually execute the simulation.
Iverilog only compiles the Verilog files into a simulation executable (.out).
./ runs that compiled executable, producing the simulation results (like waveforms or printed outputs).

<details>
  <summary> Interesting point</summary>
**1. `vvp <file>`**

- `vvp` is the Icarus Verilog runtime engine.
- Runs the compiled simulation through the Verilog simulator.
- **Example:** `vvp simulation.out`
- **Advantages:**
  - Handles Verilog-specific initialization.
  - Works consistently across platforms.

**2. `./<file>`**

- Runs the compiled executable directly like any native program.
- Works because `iverilog` produces a binary executable for your system.
- **Limitations:**
  - Some simulation features (like certain `$dump*` or `$display` handling) might require `vvp`.
  - Less portable than using `vvp`.

</details>

<details>
  <summary>Simulation Logs</summary>

![](/images/simlog1.png)

![](/images/simlog2.png)

![](/images/simlog3.png)
   
</details>

## Simulation Results

### The code executed

```
    ADDI   r9,  r0, 1         # r9 = 1
    ADDI   r10, r0, 43        # r10 = 43 (upper bound for triangular numbers)
    ADDI   r11, r0, 0         # r11 = 0 (loop counter)
    ADDI   r17, r0, 0         # r17 = 0 (accumulator)

# ---- First loop: build triangular numbers ----
loop1:
    ADD    r17, r17, r11      # r17 = r17 + r11
    ADDI   r11, r11, 1        # r11 = r11 + 1
    BNE    r11, r10, loop1    # repeat until r11 == r10
    ADD    r17, r17, r11      # final add when r11 == r10

# ---- Second loop: subtract triangular numbers ----
loop2:
    SUB    r17, r17, r11      # r17 = r17 - r11
    SUB    r11, r11, r9       # r11 = r11 - 1
    BNE    r11, r9, loop2     # repeat until r11 == 1
    SUB    r17, r17, r11      # final subtract when r11 == 1

# ---- Infinite loop (end) ----
loop3:
    BEQ    r0, r0, loop3      # stay here forever

```
The output pattern goes like 0, 1, 3, 6, 10, 15, .. till 946 then decreases like 903, ..., 1, 0. That's how the analog waveform comes to be.

![](/images/codeworks.png)

![](/images/analog.png)

<details>
  <summary>Reset operation</summary>
   
![](/images/reset.png)

Perhaps, all register files are initialised to their number when reset, hence the number 17 as the output. 

</details>

<details>
  <summary>Clocking</summary>
   
![](/images/pll.png)

This is a close-up of the initial simulation time. Clearly, it begins with a period of 25ns, but then increases to 35ns when the reference clock edge arrives.
In short: 
   The output is 25 ns initially because that’s just the default free-running frequency of the VCO (hardcoded in the initial block). Once REF comes in, the code updates the period to match REF/8 (≈35 ns in your case).

   <details>
      <summary>why period increases eventually? </summary>
      
   1. Why is it 25 ns initially?
   In the code:
   ```
   initial begin
      lastedge = 0.0;
      period   = 25.0; // default 25ns
      CLK <= 0;
   end
   ```
   At time 0, the model doesn’t yet know the REF frequency (refpd hasn’t been measured because no REF edge has occurred).
   So it just assumes a default VCO period = 25 ns (40 MHz).
   That’s why you see CLK toggling very fast at the beginning, even though REF is much slower.
   
   2. When REF edges arrive
   ```
   always @(posedge REF) begin
      if (lastedge > 0.0) begin
         refpd = $realtime - lastedge;
         period = refpd / 8.0;
      end
      lastedge = $realtime;
   end
   ```
   On the first REF rising edge, it calculates the reference period (refpd).
   
   Example from the waveform:
   refpd ≈ 283 ns.
   period = refpd / 8 ≈ 35.4 ns.
   So, after the first REF cycle, the VCO clock slows down from 25 ns (40 MHz) to ~35 ns (≈28.3 MHz), which is exactly 8× the REF frequency.

   ![](/images/increase_period.png)
   
   </details>

</details>

<details>
  <summary>Dataflow between modules</summary>

These images show the data flow between the processor and the DAC. `OUT[9:0]` is translated into analog voltage values, which are seen in the `OUT` port of the DAC module. The crest and trough are shown respectively.

![](/images/highpoint_sim.png)

![](/images/lowpoint_sim.png)

The DAC output is stepped because it converts digital values (discrete numbers) into voltage. Each digital value produces a fixed voltage level, so the output changes in small jumps instead of a smooth continuous curve.
In short: digital → discrete steps → approximate analog, not truly continuous.

![](/images/steps_out.png)

> To get the analog waveform, select OUT port under 'dac' module, double click to see it as a waveform. It shows real values.
> Right click on the waveform, select Data Format, select Analog, select Step. For better viewing, right click on this waveform, select Insert Analog Height Extension.
  
</details>






