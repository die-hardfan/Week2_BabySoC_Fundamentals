# VSD BabySoC Functional Modelling: Theory 

This is an overview of the ports and functional description of VSDBabySoC.

## 1. avsddac.v 

This is a behavioral Verilog model (not synthesizable) that implements a simple analog-style DAC (digital-to-analog converter) in simulation using real (floating-point) arithmetic. It converts the 10-bit input D into a real voltage OUT somewhere between VREFL and VREFH. 
```text
   output      OUT;
   input [9:0] D;
   input       VREFH;
   input       VREFL;
```
The module converts the 10 bit `D` to an appropriate voltage value between `VREFH` and `VREFL`. 

<details>
  <summary>Detailed Explanation</summary>

```bash
module avsddac (
   OUT,
   D,
   VREFH,
   VREFL
);

// Port declarations (old-style Verilog)
// `OUT` declared below as a real reg; `D` is a 10-bit input, VREFH/VREFL are inputs
   output      OUT;
   input [9:0] D;
   input       VREFH;
   input       VREFL;
   
// Internal declarations
// OUT is declared as a real reg — holds floating-point value for simulation.
   reg  real OUT;
// Declares the reference pins as wires of type real (simulation-only).
   wire real VREFL;
   wire real VREFH;

// A real variable to hold a NaN value for checks (0.0/0.0 produces NaN in simulator)
   real NaN;
// Enable signal — here it is a wire driven to constant 1 below.
   wire EN;

// Extend D to 11 bits so division by 1023 works with integer numerator 0..1023
   wire [10:0] Dext;	// unsigned extended

// Zero-extend D to 11 bits: Dext ranges 0..1023
   assign Dext = {1'b0, D};
// Hardwired enable; EN is always 1 here (so DAC always enabled)
   assign EN = 1;

// initial block: executed at time 0 in simulation
   initial begin
      NaN = 0.0 / 0.0;           // create a NaN value (simulator-specific)
      if (EN == 1'b0) begin
         OUT <= 0.0;            // non-blocking assignment to OUT (unusual in initial)
      end
      else if (VREFH == NaN) begin
         OUT <= NaN;           // attempt to detect NaN on VREFH
      end
      else if (VREFL == NaN) begin
         OUT <= NaN;           // attempt to detect NaN on VREFL
      end
      else if (EN == 1'b1) begin
         // compute analog output as linear interpolation from VREFL..VREFH
         OUT <= VREFL + ($itor(Dext) / 1023.0) * (VREFH - VREFL);
      end
      else begin
         OUT <= NaN;
      end
   end

// Combinational-style always block triggered when any of these signals changes
// Note: using non-blocking (<=) here is unusual for combinational logic
   always @(D or EN or VREFH or VREFL) begin
      if (EN == 1'b0) begin
         OUT <= 0.0;
      end
      else if (VREFH == NaN) begin
         OUT <= NaN;
      end
      else if (VREFL == NaN) begin
         OUT <= NaN;
      end
      else if (EN == 1'b1) begin
         // real arithmetic: convert Dext (integer) to real and scale by 1/1023
         OUT <= VREFL + ($itor(Dext) / 1023.0) * (VREFH - VREFL);
      end
      else begin
         OUT <= NaN;
      end
   end
endmodule
```
</details>

---

## 2. avsdpll.v

```text
module avsdpll (
   output reg  CLK,        // Output clock of the PLL
   input  wire VCO_IN,     // Input from VCO (not really used in this sim)
   input  wire ENb_CP,     // Charge pump enable (not used here)
   input  wire ENb_VCO,    // VCO enable (active-low)
   input  wire REF         // Reference given as real value
);
```
CLK: The output clock generated by this PLL (VCO output). Declared as reg because it will be updated in procedural blocks (always).
VCO_IN: Input to the Voltage-Controlled Oscillator. In this code, it’s not used. Possibly for future expansion or analog modeling.
ENb_CP: Enable/disable for the charge pump. Currently unused.
ENb_VCO: Enable for the VCO. Controls whether the output CLK toggles or is held low.
REF: Reference clock input. The PLL locks to this clock

<details>
  <summary> Detailed Explanation </summary>
  
</details>

---

## 3. rvmyth.tlv

```text
   module rvmyth(
      output reg [9:0] OUT,
      input CLK,
      input reset
   );
```
`OUT`: reflects the contents of register `r17` within the register file. 
`CLK`: input clock signal required for functioning of the core
`reset`: active high reset that pulls relevant values (like PC, rd_en) to 0. 

<details>
  <summary> Detailed Explanation </summary>
  
</details>

---

## 4. vsdbabysoc.v
This is the wrapper function that makes the interconnections between the 3 components.

```text
module vsdbabysoc (
   output wire OUT,
   input  wire reset,
   input  wire VCO_IN,
   input  wire ENb_CP,
   input  wire ENb_VCO,
   input  wire REF,
    input  wire VREFL,
   input  wire VREFH
);
```

`OUT`: Final output of the SoC (from the DAC).
`reset`: Resets the RISC-V core.
`VCO_IN`: Input to the PLL's VCO (currently used in the PLL module).
`ENb_CP`: Enable/disable the charge pump in the PLL.
`ENb_VCO`: Enable/disable the VCO output.
`REF`: Reference clock for the PLL.
`VREFH`: DAC reference voltage (high).
`VREFL`: DAC low reference (commented out, possibly defaulted to 0).

<details>
  <summary> Detailed Explanation </summary>
  
</details>

---

## 5. testbench.v
The testbench module doesn't have any ports and is responsible for stimulus generation and observation.

<details>
  <summary> Detailed Explanation </summary>
  
</details>


# VSD BabySoC Functional Modelling: Labs

## Environment Setup

**Tools required:** 
 - git (for git cloning the source files)
 - sandpiper environment (required for .tlv to .v conversion cuz processor source code is in TL-Verilog)
 - python3 (to install sandpiper)
 - iVerilog (for simulation)
 - GTKwave (for waveform viewing)

All this is being done on an Ubuntu terminal.

```bash
sudo apt update
sudo apt-get install python3 python3-pip //to install python
```
Python is now installed. To install `sandpiper` : 
```bash
pip3 install --user pyyaml click sandpiper-saas //this didn't work on my system, but it maybe used
```
OR 
```bash
sudo apt install pipx //install pipx
pipx install sandpiper-saas
pipx ensurepath 
```
<details>
  <summary> why pip install didn't work </summary>
  
Ubuntu 22.04+ (or Debian-based systems) now use PEP 668 “externally managed environments”.
This means:
The system Python (/usr/bin/python3) is managed by the OS package manager (apt).
You are not allowed to install Python packages system-wide using sudo pip3.
Doing so can break system tools that rely on the OS Python.
Sandpiper is probably not a Debian packaged application, so it may be easiest to use pipx install xyz, which will manage a virtual environment for you. Make sure you have pipx installed.
Some changes to the path may be required after the command. 
> pipx ensurepath
This ensures that pipx’s binary installation directory is added to your system PATH so installed packages can be run from the command line.
</details>

The SandPiper code generator helps you write Verilog or SystemVerilog code more productively from TL-Verilog. Most open-source projects use SandPiper SaaS, which provides a command-line interface to run SandPiper in the cloud.
```bash
sanpiper-saas -i my.tlv -o my.sv //command for conversion
```
git, iVerilog, and GTKwave have been installed as part of earlier tasks.

---

## Simulation 

1. Git clone the project files from [here](https://github.com/manili/VSDBabySoC).
```bash
git clone https://github.com/manili/VSDBabySoC week2_files
```
2. Translation of rvmyth.tlv into .v files.
```bash
sandpiper-saas -i rvmyth.tlv -o rvmyth.v
```
This generates two files, `rvmyth.v` and `rvmyth_gen.v`. Both of them are necessary for proper simulation. 
Include both files when compiling. The testbench instantiates the main module from `rvmyth.v`. `rvmyth_gen.v` provides the necessary supporting definitions.
Also, all lines with `line in rvmyth.v file must be commented out (it leads to unexpected error otherwise).
<details>
  <summary>Why error?</summary>

Lines like:
```
`line 254 "rvmyth.tlv" 2
```
are TL-Verilog “line directives” used for debugging/error reporting.
Icarus Verilog does not understand them unless you explicitly enable SystemVerilog (-g2012) and even then, some TLV-generated directives are not supported.
</details>

3. Simulate the files.
```bash
iverilog -g2012 -o ~/week2_files/output/pre_synth_sim/pre_synth_sim.out -DPRE_SYNTH_SIM -I ~/week2_files/src/include -I ~/week2_files/src/module ~/week2_files/src/module/testbench.v //simulation
cd output/pre_synth_sim //navigate to the output directory
./pre_synth_sim.out //execution of the .out file
gtkwave pre_synth_sim.vcd //waveform viewing
```
-g2012 : Use the Verilog 2012 standard.
-o <output_file_path> : Specify the output file for the compiled simulation executable.
-D<MACRO_NAME> : Define a preprocessor macro for conditional compilation.
-I <include_dir1> -I <include_dir2> : Add directories to the search path for `\`include` files.
<verilog_file> : The main Verilog file (usually a testbench) to compile.

Don't include `vsdbabysoc.v` module in the simulation command, cuz the testbench already includes it.

> ./pre_synth_sim.out
is required to actually execute the simulation.
Iverilog only compiles the Verilog files into a simulation executable (.out).
./ runs that compiled executable, producing the simulation results (like waveforms or printed outputs).

<details>
  <summary> Interesting point</summary>
**1. `vvp <file>`**

- `vvp` is the Icarus Verilog runtime engine.
- Runs the compiled simulation through the Verilog simulator.
- **Example:** `vvp simulation.out`
- **Advantages:**
  - Handles Verilog-specific initialization.
  - Works consistently across platforms.

**2. `./<file>`**

- Runs the compiled executable directly like any native program.
- Works because `iverilog` produces a binary executable for your system.
- **Limitations:**
  - Some simulation features (like certain `$dump*` or `$display` handling) might require `vvp`.
  - Less portable than using `vvp`.

</details>

<details>
  <summary>Simulation Logs</summary>
  //add images here
</details>

## Simulation Results

<details>
  <summary>Reset operation</summary>
  //add images here
Perhaps, all register files are initialised to their number when reset, hence the number 17 as the output. 

</details>

<details>
  <summary>Clocking</summary>
  //add images here
</details>

<details>
  <summary>Dataflow between modules</summary>

These images show the data flow between the processor and the DAC. `OUT[9:0]` is translated into analog voltage values, which are seen in the `OUT` port of the DAC module. The crest and trough are shown respectively.
//image here
//image here

The DAC output is stepped because it converts digital values (discrete numbers) into voltage. Each digital value produces a fixed voltage level, so the output changes in small jumps instead of a smooth continuous curve.
In short: digital → discrete steps → approximate analog, not truly continuous.
//image here

> To get the analog waveform, select OUT port under 'dac' module, double click to see it as a waveform. It shows real values.
> Right click on the waveform, select Data Format, select Analog, select Step. For better viewing, right click on this waveform, select Insert Analog Height Extension.
  
</details>






